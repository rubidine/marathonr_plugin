module BackgroundTasks
  ##
  #
  # Do all the work for an ajax poll to the last sent job
  #
  def background_poll
    if (req = background_alive?).nil?
      render :text => "Unable to retreive status, retrying",
             :status => 500
    elsif req.complete?
      if req.error?
        render :text => "
          Error occurred during processing.
          <br/>
          Status Message: #{req.status_message.gsub(/</, '&lt;')}
          <br/>
          Data: #{req.data.inspect.gsub(/</, '&lt')}
        "
      elsif req.filetype
        render :text => "
          <script type='text/javascript'>
          enable_poll = false;
          location.href = ('/#{params[:controller]}/background_file');
          </script>"
      else
        response.content_type = "text/html"
        response.body = background_output(req)
        @performed_render = true
        background_cleanup(req)
      end
    else
      render :text => background_message(req), :status => 202
    end
  end

  ##
  #
  # Download a file that was generated by a background method.
  # The name of the file is stored in the session.
  # User is automatically directed here if the status of the background job
  # has the key :filetype
  #
  def background_file
    if (req = background_alive?).nil?
      render :text => "Unable to find file for delivery."
    elsif !background_complete?(req)
      render :text => "File is not ready.  Please refresh page."
    else
      begin
        response.content_type = req.filetype
        response.body = background_output(req)
        response.headers['Content-Disposition'] = "attachment; filename=\"#{req.filename || req.worker_name}\""
        @performed_render = true
        background_cleanup(req)
      rescue
        render :text => "Unable to download file: #{$!}"
      end
    end
  end

  private

  ##
  #
  # Launch a new background task. Calls render for you, make sure that you
  # are sure that you don't call it, also.
  #
  def background(worker, args)
    req = Marathonr::WorkRequest.create!(
                :worker_name => worker.to_s,
                :job_key => session.session_id,
                :data => args
              )
    session[:job_request_id] = req.id
  end

  ##
  #
  # Return nil if worker is not alive
  # otherwise reutrns the status object
  #
  def background_alive?
    Marathonr::WorkRequest.find(session[:job_request_id])
  end

  ##
  #
  # Give back the status from background_alive?
  #
  def background_complete?(req)
    req.complete?
  end

  ##
  #
  # Get the output from a completed background task
  # Status is what background_alive? returned
  # (This will be obseleted by memcached)
  #
  def background_output(req)
    body = req.data
    if !body
      "<script>
       prototype_dialogs['generatingReport'].close();
       enable_poll = false;
       </script>
       No data returned"
    else
      body
    end
  end

  ##
  #
  # Delete memory consuming parts of the background agent
  #
  def background_cleanup req
    session[:job_request_id] = nil
    req.destroy
  end

  ##
  #
  # Show a message to the user based on the status of the process
  #
  def background_message(req)
    if req.current_stage_max_step > 0
      pct = req.current_stage_step.to_f / req.current_stage_max_step * 100
    else
      pct = nil
    end

    "#{req.status_message}<br/>#{req.current_stage_name}#{pct ? ' - %.1f%' % pct : ''}"
  end

end
